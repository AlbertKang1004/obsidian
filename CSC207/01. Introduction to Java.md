## Running a Program
The code must be **translated** into **machine code** that is eventually executed on the physical hardware.
There are two ways on how this translation takes action.
1. **Interpretation** : The program is read and executed line-by-line by another program called an interpreter. (ex. Python)
2. **Compilation** : The entire program is translated into **machine code** ahead of time by a compiler, producing an executable file. (ex. C)
For Java, it's a combination of both.
![[java compiler diagram.png|600]]
- Starts with `HelloWorld.java`
- Compile it by running `javac HelloWorld.java`
- Produces a file called `HelloWorld.class`, which contains the **bytecode**
- **Java Virtual Machine (JVM)** will interpret and optimize this **bytecode** at runtime
- To run the program, type `java HelloWorld.class`
The layer of Java's architecture will look like:
![[Java Structure Diagram|300]]

## First Look at Java

### Defining Classes
```java
class Hello {
	// Methods will go here.
}
```
### Defining Methods
```java
class Hello {
	public static void main(String[] args) {
		// The method body will go here.
	}
}
```
### Printing Text
```java
class Hello {
	public static void main(String[] args) {
		System.out.println("Hello!");
	}
}

```

----
## Variables & Types
### Declaring types
```java
int i; // haven't assigned a value yet
int j = 42; // creating a variable and assigning a value
int k = 19.0; // will cause an error: type mismatch
double l = 22; // however, this is fine as 22 can be converted into double
int i = 10; // cannot initialize a variable with a same name twice
```
### Other possible types
```java
int age = 21;
String name = "Jake";
boolean graduated = false; // true or false
```
### References vs. Primitives
```java
public class Simple {
    public static void main(String[] args) {
        int age = 21;
        String name = "Jude";
        System.out.println("Ciao!");
    }
}
```
- Reference types start with **Uppercase**, like `String`, `List`.
- Primitive types start with **lowercase**, like `int`, `char`.
> In reference types, `==` compares their references (if they are pointing to the same object).
> In primitive types, `==` compares their values.

![[Memory Diagram 1|600]]
- **Call Stack** is where we keep track of the method that is currently running
- **Object Space** is where objects are stored
- **Static Space** is where static members of a class are stored
----
## Strings
Java has a class `String` that represents sequences of characters. 
```java
String s1 = new String("Hello");
String s2 = "bye" // shorter version
```
### String Pool
```java
String s1 = "Hello";
String s2 = "Hello";
System.out.println(s1 == s2); // True

String s3 = new String("Hello");
String s4 = new String("Hello");
System.out.println(s3 == s4); // False
```
- In Java, if we initialize a `String s1` without `new` keyword, then Java will throw the value of the String `"Hello"` into the **String pool**. 
- When creating `s2` without `new` as well, Java looks for `"Hello"` inside the **String pool** to avoid using excessive memory.
- However, creating a `String` with `new` keyword will create a `String` class with instance `"Hello"`. Since both are different **Object**s, the result will be `false`.

> `String` is an immutable datatype.

### String Manipulation
```java
String s1 = new String("Hello ");
String s2 = new String(" World!");
String s3 = s1 + s2; // Hello World!
char c = s3.charAt(2); // l (newStr[2])
s3.subString(2, 5); // llo (newStr[2:5])
s3.trim(); // trims proceding/conceding whitespaces
```
### Mutable Strings : `StringBuilder`
```java
StringBuilder sb = new StringBuilder("ban");
sb.append("phone"); // banphone
sb.insert(3, "ana"); // bananaphone
sb.setCharAt(3, "o"); // banonaphone
sb.reverse(); // enohpanonab
```
### Single Character `String`: `Char`
```java
char c = 'x'; // we use single quotes instead of ""
```
----
## Classes
### Abstractions
An *abstraction* is a simplified view of something complex.
- For example, memory model can be an abstraction on how the computer works
- **Class** and **Interface** are types of abstraction in Java
### Instantiating an Object
```java
StringBuilder name = new StringBuilder("Victory");
```
 - When creating an object, `new` keyword is required.
 - In brackets `()`, we provide *arguments* for the constructor.
 - When Java evaluates the code above, it:
	 1. allocates memory for the new object
	 2. static variables are initialized once
	 3. instance variables are initialized
	 4. calls the appropriate constructor (superclass constructor → subclass constructor)
	 5. returns a reference to the newly-constructed object
### API
- Short for Application Programming Interface
- Tells us what methods we can call, what arguments we must send, and what value will be returned.
- Does **not** tell us how the class provides these services.
### Calling Methods
```java
String band = "Arcade fire";
// call an instance method via an instance.
int size = band.length();
```
- We call an instance method via a reference to an instance of a class.
### Class Methods
```java
// call a class method via the class name.
double x = Math.cos(48);
```
- Some methods are associated not with individual instances of a class, but with the class as a whole.
### Accessing Data Members
```java
System.out.println(Integer.BYTES);
```
- If a class has an instance or class variable (also known as `static` variable) that is accessible to code outside the class, it can be referred to via an instance variable or the class name respectively.
### Garbage Collection
```java
String s1 = new String("Hi!");
s1 = null;
```
- If the object is not used anymore, we can explicitly drop a reference by setting the variable holding the reference to `null`. 
- This can hasten garbage collection and improve performance.
## Arrays
Arrays are the type Java provides for storing a collection of items.
- Arrays have a fixed length
- All elements must have the same type, which we must state at the initialization
### Declaring an Array
```java
int[] numbers;
```
- Declares an array of `int`
- Arrays are reference types — meaning that when we declare an array, we are creating a variable that will refer to an array.
- Arrays in Java are reference types, meaning the variable does not hold the actual data.
### Constructing an Array
```java
int[] numbers = new int[5];
// Alternative way
int[] primes = {2, 3, 5, 7, 11};
```
- Creates an array of `int` with a length(size) of `5`.
- We can define the length of array at runtime too.
### Determining Length
```java
int sibling = new int[numbers.length]
```
- We can find the length of an array by accessing its `length` attribute.
### Accessing Elements in Array
```java
numbers[1] = 512;
numbers[-2] = 999; // same as numbers[3] = 999 (accessing 2nd last element)
int[] specials = numbers[1:4] // silcing array and making a copy
```
### Two-dimensional Array
```java
int[][] table;
table = new int[50][3];
table[49][2] = 123; // this is legal
table[2][49] = 456; // this is out of bounds
```

----
## Aliases
### Aliasing and its Implications
- For **reference** types, we store a reference to an object inside them.
- We must follow the reference to get to the values and methods stored in the object
### Creating Aliases with References
```java
String name = new String("Jake");
String student = name;
```
![[Memory Diagram 2|600]]
- We have two variables, `name` and `student`, referencing the same `String` object. We call them **aliases**.
- We cannot create **aliases** with **primitive types**.
- ![[Memory Diagram 3]]
---
## Control Structures
### `if` statements
```java
int classSize = 124;
int sections = 1;
if (classSize > 100) {
	sections = 2;
	classSize = classSize / 2;	
}
```
or we can add `else if`, `else` block for the additional behavior.
```java
int grade = 86;
char letterGrade;
if (grade > 80) {
    letterGrade = 'A';
} else if (grade > 70) {
    letterGrade = 'B';
} else if (grade > 60) {
    letterGrade = 'C';
} else if (grade > 50) {
    letterGrade = 'D';
} else {
    letterGrade = 'F';
}
```
### `for` loops
**Basic Structure**
```
for (initialization; termination; increment) {
	loop body
}
```
**Example**
```java
int n = 15;
int sum = 0;
for (int i = 1; i <= n; i++) {
    sum += i;
}
System.out.println("Sum of the first " + n + "numbers is " + sum);
```
### Enhanced `for` loops
```java
for (int p : powers) {
    System.out.println(p);
}
```
- This causes `p` to loop through elements of `powers`, which is a *Collection*.
### `while` loops
**Basic Structure**
```java
while (condition) {
    ...
}
```
**Example**
```java
int number = 37;
int divisor = 7;
while (number > divisor) {
    number = number - divisor;
}
// We know here that (n > divisor) is false.
System.out.println("Leftover: " + number);
```
### `do`-`while` loops
**Basic Structure
```java
do {
    // your code inside
} while (condition); // Note the semicolon at the end of the block.
```
---
## Parameters
```java
public static void messAbout(int n, String s) {
    // Contents of the method omitted.
}

public static void main (String[] args) {
    int count = 13;
    String word = new String("nonsense");
    messAbout(count, word);
}
```
- `n` and `s` are **parameters** of method `messAbout`.
	- When we call a method, each variable `count`, `word` is called an **argument**.
- When we call a method, the following happens:
	1. A new stack frame is pushed onto the call stack.
	2. Each parameter is defined in that stack frame.
	3. The value contained in each argument is assigned to its corresponding parameter.
### Passing a Primitive vs. Reference as Argument
**Primitive**
```java
static void increase(int i) {
    i = i + 1000;
}

public static void main(String[] args) {
    int cost = 14;
    increase(cost);
    System.out.println(cost);
 }
```
**Memory Model** (Primitive)
![[Memory Diagram 4|600]]
**Reference**
```java
static void increase(StringBuilder sb) {
    sb.append(sb);
    sb.append("!");
}

public static void main(String[] args) {
    StringBuilder word = new StringBuilder("rah");
    increase(word);
    System.out.println(word);
}
```
**Memory Model** (Reference)
![[Memory Diagram 5|600]]
- When we call method `increase`, a new frame was pushed onto the call stack.
- In the upper left corner, we write the method name.
- In the upper right corner, we write what the method belongs to, in this case, class `Parameter`.
- The parameter `sb` exists in the stack frame. It comes into being when the method is called. 
- When the method returns, this stack frame will be popped off the stack and discarded. At that point, `sb` no longer exists.
	- When we passed argument `word` to parameter `sb`, we assigned its value to `sb`. In other words, we copied what was in the box: `id29`. this created an **alias**.
- `id29` is a reference to a `StringBuilder` object, which is **mutable**. When we used `sb` to access and change that object, the object that `word` references also changed, since they refer to the same object.
### Passing a Reference to an Immutable Object
```java
static void increase(String s) {
    // We can't call a method to append to s, because String doesn't have
    // such a method.  But we can use the concatenate operator.
    s = s + s + "!";
}
 
public static void main(String[] args) {
    String sound = "moo";
    increase(sound);
    System.out.println(sound);
```
**Memory Model**
![[Memory Diagram 6|600]]
- Although we set up an **alias** just like before, we can't change the object that both `sound` and `s` reference, so we make a new object.
---
## Compile-time Error vs. Runtime Error
**Compile-time Error**: Detected by the compiler before the program runs.
```java
int x = "hello"; // type mismatch, compiler fails
```
**Runtime Error**: Occurs when the program is running after successful compilation
```java
int[] arr = {1, 2, 3};
System.out.println(arr[5]); // ArrayIndexOutOfBounds
```

