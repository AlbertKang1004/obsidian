## The Dependency Rule
- The **Clean Architecture** has one rule, called the "**Dependency Rule**". 
- This rule states that the dependencies in our system must all point inwards —  from lower-level policies to higher-level policies
## The Clean Architecture with SOLID Principle
- Adheres to **[[09. Design Principles#Single Responsibility Principle (SRP)|Single Responsibility Principle]]**
	- Clean Architecture follows SRP as each layer of Use Cases has a clearly defined responsibility.
- Adheres to **[[09. Design Principles#Dependency Inversion Principle (DIP)|Dependency Inversion Principle]]**
	- Clean Architecture follows DIP by having high-level modules depend only on abstractions not on low-level details. 
	- Low-level modules implement these abstractions, so all dependencies point inward toward the core logic.
### Diagram
![[The Dependency Rule|600]]
## The Clean Architecture Engine
![[CA.png]]
### Frameworks and Drivers
#### View
Displays information and reacts to user interaction. 
- The **View** will ask a **Controller** to do something user wants. 
- The information that the **View** displays is stored in **View Model**.
- When the **View Model** is updated, the **View** is alerted and will display the new information to the user.
#### Data Access
Reads and write persistent data to a file or database outside the program. 
- It implements its method from the **Data Access Interface** specified by the <u><b>Use Case</b></u> layer. 
- It will create temporary **Entities** that the <u><b>Use Case</b></u> uses to do its work.
### Interface Adapters
#### Controller
- Converts the raw user data to something useful (ex. `String`  →  `Date` ).
- Creates an **Input Data** object containing that information.
- Calls a method to start a <u><b>Use Case</b></u>, passing in the **Input Data**.
#### Presenter
- Receives information as **Output Data** object from the **Use Case Interactor** and turns it into raw strings and numbers to be displayed. 
- Then, it updates the **View Model** with this information.
#### View Model
A storage class for information the **View** needs to display.
- The **View** accesses the **View Model** for any information it needs.
### Application Business Rules (Use Cases)

#### Input Data
- The **Controller** creates this object and stores input from the user in it. 
- Later passed to the **Use Case Interactor**.
- Designed to be in a format most convenient for the Use Case Interactor to do its job.
#### Use Case Interactor
- Takes the **Input Data** and executes the <b><u>Use Case</b></u>.
- Looks up information in the **Data Access Object** when necessary.
- Manipulates **Entities**, which might create new data that needs to be saved through a **Data Access Object**.
- When complete, create an **Output Data** object (the <b><u>Use Case</b></u> result) and pass it to the **Presenter**.
#### Output Data
Represents the result of executing the **Use Case Interactor**.
- The **Use Case Interactor** creates this object and sends it to the **Presenter** through the **Output Boundary**.
#### Input Boundary
Implemented by a **Use Case Interactor**.
- **Controller** classes call the methods in this interface.
#### Output Boundary
Implemented by a **Presenter**.
- **Use Case Interactor** calls the methods in this interface.
#### Data Access Interface
Implemented by a **Data Access** class.
- Specifies how the **Use Case Interactor** will need to access data in order to perform its job.
### Enterprise Business Rules
#### Entities
Class that stores information about the building blocks of your program. 
- For example, a car rental app will have `Car`, `Renter` entities, and so on.
## Clean Architecture In Action
![[CA in Action.png]]
### Step 1: View → Controller
- The user interacts with the **View**.
- Triggers an event that contains input from the user that is passed to the **Controller**.
### Step 2: Controller → Input Boundary (Use Case Interactor)
- The **Controller** bundles the input from the user into an **Input Data** object and passes that through the **Input Boundary**.
- Calls a method defined in the **Input Boundary** interface that takes an **Input Data** object as a parameter.
### Step 3: Use Case Interactor → Data Access Interface (Data Access)
 - As part of its work, the **Use Case Interactor** may need to read data through the **Data Access Interface**.
 - It may request to get an **Entity** object given information from the **Input Data** object that was passed in by the **Controller**.
### Step 4: Data Access → Database
- The **Data Access** object does what it needs to do to read data from whatever database is used to actually store the data.
### Step 5: Use Case Interactor → Entities
- Once the **Use Case Interactor** has the **Entity** objects that it needs from the **Data Access Object**, it uses the methods of the **Entities** to complete its work.
### Step 6: Use Case Interactor → Output Boundary (Presenter)
 - Once the **Use Case Interactor** finishes its work, it creates an **Output Data** object and passes that through the **Output Boundary**.
 - Calls a method defined in the **Output Boundary** interface that takes an **Output Data** object as a parameter.
### Step 7: Presenter → View Model
- **Presenter** takes the information from the **Output Data** object and updates the **View Model** to reflect the result of the user interaction. 
- The **View** will be alerted of this change and can update itself accordingly. 
- At this point, the interaction is complete and the user will see the updated **View**.
## Testing with the Clean Architecture
```java
@Test  
void successTest() {  
    LoginInputData inputData = new LoginInputData("Paul", "password");  
    LoginUserDataAccessInterface userRepository = new InMemoryUserDataAccessObject();  
  
    // For the success test, we need to add Paul to the data access repository before we log in.  
    UserFactory factory = new UserFactory();  
    User user = factory.create("Paul", "password");  
    userRepository.save(user);  
  
    // This creates a successPresenter that tests whether the test case is as we expect.  
    LoginOutputBoundary successPresenter = new LoginOutputBoundary() {  
        @Override  
        public void prepareSuccessView(LoginOutputData user) {  
            assertEquals("Paul", user.getUsername());  
            assertEquals("Paul", userRepository.getCurrentUsername());  
        }  
  
        @Override        public void prepareFailView(String error) {  
            fail("Use case failure is unexpected.");  
        }  
    };  
  
    LoginInputBoundary interactor = new LoginInteractor(userRepository, successPresenter);  
    interactor.execute(inputData);  
}
```
We can test a **Use Case Interactor** by mocking the **Presenter**.
- In the actual code, **Presenter** receives **Output Data** object and pass it to a **View Model** with the format that's easier to display.
- In the **unit test**, we don't have to display anything, so we [[03. Relationships Between Classes#Overriding Methods|override]] methods from the **Presenter** to compare the output to the correct value using `assert`.
- ```java
  assertEquals(expected, actual);   // checks equality
assertTrue(condition);            // checks if condition is true
assertFalse(condition);           // checks if condition is false
assertNotNull(object);            // checks if object is not null
assertNull(object);               // checks if object is null
assertThrows(Exception.class, () -> method()); // expects exception
  ```
