## Creational Patterns
### Factory
>**Problem** : You need to create objects that are all subclasses or implementing classes of the same abstraction, but you don't want your code to depend on the exact class names or how they're built.

>**Solution** : Using the **Factory** pattern, you can replace direct object construction calls (using the `new` operator) with calls to a special `Factory` object / method.
- The objects are still created with the `new` operator but it's being called from within the `Factory` object / method.
#### Simple Factory
Uses a method (usually `static`) to create objects based on input parameters. It can produce different concrete types that share a common interface or superclass.
```java
public class ShapeFactory { 
    public Shape getShape(String shapeType) {
        switch(shapeType) {
            case "Rectangle": 
                return new Rectangle(); 
            case "Circle": 
                return new Circle(); 
            case "Square": 
                return new Square();
            default:
                throw new IllegalArgumentException(
                        "Wrong shape type: " + shapeType
                );
        }
    }
}
```
- If your program requires `Shape` objects, but doesn't need to know if they are `Rectangle`, `Circle`, `Triangle`, or any other shape that you might want to include in the future, you can instantiate those classes using a `ShapeFactory` class.

```java
ShapeFactory shapeFactory = new ShapeFactory();
Shape shape = shapeFactory.getShape(userInput);
// do something with the shape...
```
- **Reduces Dependencies** : it won't directly call `new Rectangle()` or `new Circle()`, it only asks the `Factory`.
- **Encapsulate creation logic** : Any setup, validation, or complex construction happens inside the `Factory`.
- **Improves Extensibility** : new shapes affects only the factory, not all client code
#### Abstract Factory
uses *composition* to delegate the instantiation logic to another object. This creates a family of one or more related objects.
```java
public abstract class ShapeFactory {
    public abstract Shape getShape();
}
```
- The first class we need is the abstract class that defines what it means to be a "Shape Factory".
```java
public class RectangleFactory extends ShapeFactory {
    public Shape getShape() {
        return new Rectangle();
    }
}

public class CircleFactory extends ShapeFactory {
    public Shape getShape() {
        return new Circle();
    }
}

public class SquareFactory extends ShapeFactory {
    public Shape getShape() {
        return new Square();
    }
}
```
- Now we can create `Factory` classes for each shapes.
```java
public class Main {
    public static void main(String[] args) {
        ShapeFactory factory = new CircleFactory(); 
        Shape shape = factory.getShape();
    }
}
```
- There's no need for a `switch` statement anymore. 
- The only part that needs modification is `new CircleFactory()`, when we decide to change the shape.
- Note that if the creation of shape depends on the **user input**, we can't use this approach.
#### UML Diagram
![[UML Factory.png]]

| Aspect           | Simple Factory                                       | Abstract Factory                                           |
| ---------------- | ---------------------------------------------------- | ---------------------------------------------------------- |
| Creation Logic   | All in one class                                     | Distributed across subclasses                              |
| Adding new types | Add a new if-statement<br>(**modify** existing code) | Add a new `Factory` subclass<br>(**extend** existing code) |
| Client usage     | Client specifies type through<br>`String` parameter  | Client chooses the `Factory`                               |
### Builder
>**Problem** : Creating a complex object with many parts or options makes your code messy and hard to read.

>**Solution** : Use a step-by-step **builder** that assembles the object piece by piece, then gives you the finished product.

```java
public String toString() {
	return new StringBuilder()
			 .append("Hatchimal{")
			 .append("name='").append(name).append('\'')
			 .append(", rarity=").append(rarity)
			 .append('}')
			 .toString();
	}
```
 - This follows a **Builder** pattern : 
	 1. Create a `Builder` object (`StringBuilder`)
	 2. Add parts to it step-by-step (`.append()`)
	 3. Get the final product (`.toString`)

```java
User u = new User.Builder()
        .setName("Bob")
        .setAge(20)
        .setEmail("bob@example.com")
        .build();
```
- **Builder** pattern begins by calling `new Builder()`, which creates a separate object used only for configuration.
- Chain configuration with `.methodName()`, where each method updates the builder’s internal fields and then returns the builder itself.
- Finish with `.build()`, which performs any validation and constructs the final immutable object using the collected values.
#### UML Diagram
![[UML Builder.png|500]]
## Behavioural Patterns
### Strategy
>**Problem** : You have several algorithms to do the same task, and you want to switch between them easily.

>**Solution** : Implement each algorithm in its own class and make them interchangeable, so that you can change the algorithm without changing the code that uses it.

```java
public interface PaymentStrategy {
    void pay(int amount);
}
```
- First, create an interface that defines the behaviour of each payment methods.

```java
public class CreditCardPayment implements PaymentStrategy {
    @Override
    public void pay(int amount) {
        System.out.println("Paid " + amount + " with credit card");
    }
}

public class PaypalPayment implements PaymentStrategy {
    @Override
    public void pay(int amount) {
        System.out.println("Paid " + amount + " with PayPal");
    }
}
```
- Different classes implement the same `PaymentStrategy`.
```java
public class Checkout {
    private PaymentStrategy strategy;

    public Checkout(PaymentStrategy strategy) {
        this.strategy = strategy;
    }

    public void setStrategy(PaymentStrategy strategy) {
        this.strategy = strategy;
    }

    public void process(int amount) {
        strategy.pay(amount);
    }
}
```
- Now instead of setting a single payment method, we can receive `PaymentStrategy` as the parameter and make `Checkout` behave accordingly.
#### UML Diagram
![[UML Strategy.png]]
- In the example, the `Checkout` is the **Context**. `PaymentStrategy` is the **Strategy** interface, and `CreditCardPayment`, `PaypalPayment` are the **Concrete Strategies**.

### Observer
>**Problem** : Multiple parts of your program need to react when an object changes, but you don't want tight coupling between those parts and the object being observed.

>**Solution** : Define a one-to-many relationship: when the observed object changes, all related objects get notified so that they can respond. The observed object doesn't need to know anything about the specifics of the objects observing it.

```java
public static void main(String[] args) {
	Company store = new Company("Clothing-R-Us");
	Customer jen = new Customer("Jen C");
	Parcel order1 = new Parcel("TX342", "Vancouver, BC");

	order1.addObserver(store);
	order1.addObserver(jen);
	order1.updateLocation("Calgary, AB");
	order1.updateLocation("Winnipeg, MB");
	order1.updateLocation("Toronto, ON");
}
```
In `Parcel` class, methods `addObsesrver` and `updateLocation` are defined :
```java
public void addObserver(PropertyChangeListener observer) {
	observableSupport.addPropertyChangeListener("location", observer);
}

public void updateLocation(String newLocation) {
	String oldLocation = this.location;
	this.location = newLocation;
	observableSupport.firePropertyChange("location", oldLocation, newLocation);
}
```
In `Company` class : 
```java
@Override
public void propertyChange(PropertyChangeEvent evt) {
	System.out.println("Company " + this.name + " observed a change in " +
			evt.getPropertyName() + " of " + evt.getSource());

	System.out.println(
			evt.getOldValue() + " has changed to " + evt.getNewValue() + ". ");

	System.out.println();
}
```
In `Customer` class : 
```java
@Override
public void propertyChange(PropertyChangeEvent evt) {
	System.out.println("Customer " + this.name + " observed a change in " +
			evt.getPropertyName() + " of " + evt.getSource());

	System.out.println(
			evt.getOldValue() + " has changed to " + evt.getNewValue() + ". ");

	System.out.println();
    }
```
- **Observers:** must have `propertyChange(PropertyChangeEvent evt)`.
	- This method gets called when a bound property is changed.
	- In order to get the information about the event, use these methods : 
		- `evt.getPropertyName()` 
		- `evt.getOldValue()`
		- `evt.getNewValue()`
- **Subjects (observables):** must use `PropertyChangeSupport` and call `firePropertyChange(String propertyName, Object oldValue, Object newValue)`
	- This method reports all **registered listeners** that were added via `addPropertyChangeListener(...)`.
#### UML Diagram
![[UML Observer.png]]
## Structural Patterns
### Façade
>**Problem** : A subsystem exposes many classes and operations to clients, forcing them to deal with unnecessary complexity

>**Solution** : Create a simple client-facing class (façade) that provides methods for common tasks while hiding the subsystem's complex details.

```java
public class EmployeeFacade {

    private PayCalculator payCalculator;
    private HourReporter hourReporter;
    private EmployeeSaver employeeSaver;
    
    public float calculatePay() {
       return this.payCalculator.calculatePay();  // Notice the 1-line delegation 
    }
    
    // The other methods go here and are structured the same way. 
    // They delegate to the appropriate object.
}
```
- Note that it **delegates** work to one of those three objects using the appropriate private variable.
- Clients do not interact with each subsystem directly; instead, they call the **façade**, which coordinates the necessary operations behind the scenes.
#### UML Diagram
![[UML Façade.png]]
### Adapter
>**Problem** : Two components can't work together because their interfaces don't match. This often happens when you need to reuse an existing class that was designed for a different context.

>**Solution** : Introduce an **Adapter** —  a class that translates between the expected interface and the existing one. The **adapter** exposes the interface your client code expects and internally forwards calls to the legacy class, converting inputs and outputs as needed.

This can be done by two ways : 
- **Delegation** : The adapter holds a reference to the legacy class and **delegates** work to it.
- **Inheritance** : The adapter **extends** the legacy class and adds code to be consistent with the expected interface.
#### With Delegation
```java
public class MovieTicket {

    private Ticket ticket = new Ticket(); // the class being adapted
    private String seatNumber;

    public MovieTicket(String seatNumber) {
        this.seatNumber = seatNumber;
    }

    public void sellTicket() {
        // delegate work to the Ticket class and add extra behavior
        ticket.sell();
        System.out.println("Seat: " + seatNumber);
    }
}
```
- `MovieTicket` acts as an **adapter** by holding a `Ticket` instance and **delegating** calls to it.
- We add new functionality (`seatNumber`) without modifying the original `Ticket` class.
#### With Inheritance
```java
public class MovieTicket extends Ticket {

    private String seatNumber;

    public MovieTicket(String seatNumber) {
        super(); // initialize the Ticket part
        this.seatNumber = seatNumber;
    }
    
    public void sellTicket() {
        // reuse parent's sell method and add extra behavior
        super.sell();
        System.out.println("Seat: " + seatNumber);
    }
}
```
- `MovieTicket` adapts the original `Ticket` class by **extending** it.
#### UML Diagram
![[UML Adapter.png]]
## Summary

| Category of Pattern |                Focus                 | Representive <br>Patterns |
| :-----------------: | :----------------------------------: | :-----------------------: |
|     Creational      |           Object Creation            |   `Factory`, `Builder`    |
|     Behavioural     | Object Interaction and Communication |  `Strategy`, `Observer`   |
|     Structural      |    Object and Class Organization     |    `Adapter`, `Façade`    |
