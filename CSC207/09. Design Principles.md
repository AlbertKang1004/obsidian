>**High Cohesion** : A class/module does one thing, and does it well
>**Low Coupling** : Classes depend on each other as little as possible.
## SOLID Principles
### Single Responsibility Principle (SRP)
> A class should have only one reason to change
- Each class should have a **single responsibility**, so that when the change is made in any of the classes, the programmer should only modify the classes involving that change.
	- Example: `LoginUserDAO`, `MultiplayerDAO`, `SinglePlayerDAO` are all `Data Access Object`s but they are separated so that the programmer can modify each functionality without potentially affecting other classes.
#### Example Code
❌ **Violates SRP**
```java
class UserManager {
	void saveUser(User u) { /*save to database*/ }
	void sendEmail(User u) { /* send email */ }
}
```
✅ **Follows SRP**
```java
class UserRepository {
    void saveUser(User u) { /*save to database*/ }
}

class EmailService {
    void sendEmail(User u) { /* send email */ }
}
```
### Open Closed Principle (OCP)
>A class should be open for extension but closed for modification.

- You should be able to **add new functionality** to a program without modifying the existing code.
- Often done using **inheritance** or **interfaces**
	- Example: By the **Dependency Rule** in Clean Architecture, **inner layers** (Entities, Use Case Interactors) never depend on **outer layers** (Interface Adapters, View).
	- **Outer layers** depend on **interfaces/abstractions** from the inner layers, like `InputBoundary` and `OutputBoundary`.
	- Thanks to the abstractions, you can add new functionalities without changing its core.
#### Example Code
❌ **Violates OCP**
```java
class DiscountCalculator {
    double calculateDiscount(String customerType, double amount) {
        if (customerType.equals("REGULAR")) {
            return amount * 0.05;
        } else if (customerType.equals("VIP")) {
            return amount * 0.10;
        }
        return 0;
    }
}
```
✅ **Follows OCP**
```java
// Abstraction
interface DiscountStrategy {
    double calculate(double amount);
}

// Concrete strategies
class RegularDiscount implements DiscountStrategy {
    public double calculate(double amount) {
        return amount * 0.05;
    }
}

class VIPDiscount implements DiscountStrategy {
    public double calculate(double amount) {
        return amount * 0.10;
    }
}

// Context
class DiscountCalculator {
    private DiscountStrategy strategy;

    public DiscountCalculator(DiscountStrategy strategy) {
        this.strategy = strategy;
    }

    public double calculate(double amount) {
        return strategy.calculate(amount);
    }
}

// Usage
DiscountCalculator calc = new DiscountCalculator(new VIPDiscount());
System.out.println(calc.calculate(1000)); // 100
```
### Liskov Substitution Principle (LSP)
> Subclasses should be substitutable for their base classes

- You should be able to use a subclass wherever a superclass is expected, and the program should still behave correctly.
	- Example: We started with the login logic use the local version of `DataAccessObject` but later when we changes to server version of `DataAccessObject` it works perfectly, as it is right now.
#### Example Code
❌ **Violates SRP**
```java
class Bird {
    void fly() { System.out.println("Flying"); }
}

class Penguin extends Bird {
    void fly() { throw new UnsupportedOperationException(); }
}
```
✅ **Follows SRP**
```java
interface Bird {}
class FlyingBird implements Bird {
	void fly() { 
		System.out.println("Flying"); 
	} 
}
class Penguin implements Bird {} // Does not inherit fly()
```

### Interface Segregation Principle (ISP)
> Programmers should not be forced to write or rely on interface methods they do not use

- Instead of having one large, general-purpose interface, create smaller and more specific interfaces so that implementing classes only need to implement methods they actually need.
	- Example: `Leaderboard` and `LeaderboardChart` has its own `Use Case Interactor` so that when the programmer implement a new function in `Leaderboard`, they do not have to implement all the methods involving charts.
#### Example Code
❌ **Violates ISP**
```java
interface Machine {
    void print(Document doc);
    void scan(Document doc);
    void fax(Document doc);
}

class OldPrinter implements Machine {
    public void print(Document doc) {
        System.out.println("Printing document...");
    }

    public void scan(Document doc) {
        // Old printer cannot scan, but still forced to implement
        throw new UnsupportedOperationException();
    }

    public void fax(Document doc) {
        // Old printer cannot fax, but still forced to implement
        throw new UnsupportedOperationException();
    }
}
```
✅ **Follows ISP**
```java
interface Printer {
    void print(Document doc);
}

interface Scanner {
    void scan(Document doc);
}

interface Fax {
    void fax(Document doc);
}

class MultiFunctionPrinter implements Printer, Scanner, Fax {
    public void print(Document doc) { /* ... */ }
    public void scan(Document doc) { /* ... */ }
    public void fax(Document doc) { /* ... */ }
}

class SimplePrinter implements Printer {
    public void print(Document doc) { /* ... */ }
}
```
### Dependency Inversion Principle (DIP)
> High-level modules should not depend on low-level modules

#### Image: Without DIP
![[Without DIP.png]]
####
- In this diagram, `HighLevel` directly depends on the `LowLevel`.
- `HighLevel` is **tightly coupled** to the implementation details of `LowLevel`, so any change in `LowLevel` could affect `HighLevel`.
#### Image: With DIP
![[DIP.png]]
- Now, we have inverted the dependency by introducing an abstraction:
	- `Interface` defines the contract (`f()`)
	- `LowLevel` implements `Interface`
	- `HighLevel` depends on `Interface`, not on `LowLevel`
####
- Notice that nothing points at `LowLevel` anymore. Now we can freely replace `LowLevel` with a different implementation of the interface as needed.
	- Example: As Clean Architecture has `Presenter` class implementing `OutputBoundary`, if there is higher type of `Presenter` we implement `OutputBoundary` instead of `Presenter`.
#### Example Code
❌ **Violates DIP**
```java
class MySQLDatabase {
    public void saveData(String data) {
        System.out.println("Saving data to MySQL: " + data);
    }
}

class UserService {
    private MySQLDatabase database = new MySQLDatabase();

    public void registerUser(String username) {
        // High-level module depends directly on low-level module
        database.saveData(username);
    }
}
```
✅ **Follows DIP**
```java
// Abstraction
interface Database {
    void saveData(String data);
}

// Low-level module
class MySQLDatabase implements Database {
    public void saveData(String data) {
        System.out.println("Saving data to MySQL: " + data);
    }
}

// High-level module
class UserService {
    private Database database;

    public UserService(Database database) {
        this.database = database; // depends on abstraction
    }

    public void registerUser(String username) {
        database.saveData(username);
    }
}

// Usage
Database db = new MySQLDatabase();
UserService service = new UserService(db);
service.registerUser("Alice");
```
