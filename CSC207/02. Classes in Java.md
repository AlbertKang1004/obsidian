## Variables in Classes
There are two kinds of variables we can declare for classes:
1. **Instance Variables** : Every instance of the class will contain its own instance of each of these variables. 
	- They come into existence when the instance is constructed (using `new` keyword)
2. **Class Variables** : Also known as **static variables**, all instances of a class share a *single*  instance of each class variable.
	- Updating this variable in one instance of a class will reflect across every instance of the class.
---
## Visibility and Access Modifiers

|  Modifier   | Class | Package | Subclasses | Global |
| :---------: | :---: | :-----: | :--------: | :----: |
|  `public`   |   O   |    O    |     O      |   O    |
| `protected` |   O   |    O    |     O      |   X    |
|  `package`  |   O   |    O    |     X      |   X    |
|  `private`  |   O   |    X    |     X      |   X    |
- If no access modifier keyword is included, the variable is `package-protected` which is equal to `protected` but excludes subclass access from outside the package.
---
## Constructors
```java
public Something() {
	this.name = "jake"
	this.size = 1
	// this("jake", 1);
}

public Something(String name, int size) {
	this.name = name;
	this.size = size;
}
```
- We can define as many constructors as we want as long as the **method signatures** are different. 
- `this` is a reference to the object whose method or constructor is being executed.
- `this("jake", 1)` calls the constructor below.
### Object Creation Order
When you create a new object in Java using `new` keyword:
1. Memory is allocated for the object.
2. Instance variable are initialized to their default values.
3. Direct initializations (e.g., `int x = 5;`) are executed in the order they appear in the class.
4. The constructor is called, which may further modify the instance variables.
5. If the class extends another class, the superclass constructor is called *first*.
## Overloading Methods
```java
public int my_method(int a, int b){
    return a + b;
}

public int my_method(int a){
    return my_method(a, 1);
}
```
- When we define a method with same name but different signature, we are **overloading** the method. Above code can be an example of **overloading**.
> Order of arguments also matter (`String a, int b` is different to `int b, String a`)
## Overriding Methods
- We could redefine a method from a parent class in order to override it.
- The `@Override` annotation will let Java enforce that we use the correct method signature for the overridden method.
### toString
```java
@Override
public String toString(){
    return "My name is " + this.name;
}
```
- This method takes no parameters and returns a `String`.
### equals
```java
@Override
public boolean equals(Object obj) {
    if (this == obj){
        return true;
    }
    if (obj == null){
        return false;
    }
    if (this.getClass() != obj.getClass()){
        return false;
    }

    MyClass other = (MyClass) obj;  
    // Here we're casting the type of obj to our class
    // And then we'll want to compare the attributes of this to those of other
    // For example:
    if (this.name != other.name){
        return false;
    } else if (this.something != other.something){
        return false;
    }
    return true;
}
```
- Note: method signature has to be `equals(Object obj)` as it is overriding Java's default `equals` method. Therefore, we have to cast obj into `MyClass` inside the method.
- Unlike Python, using `==` will **not** call `equals` method.
- Any implementation of `equals` must obey these properties:
	1. **Symmetry** : For non-null references `a` and `b`, `a.equals(b)`$\iff$`b.equals(a)`
	2. **Reflexivity** : `a.equals(a)` is **true**.
	3. **Transitivity** : `a.equals(b)`$\land$ `b.equals(c)`$\implies$`a.equals(c)`
### hashCode
 - Whenever we override the `equals` method, we **must** override another inherited method called `hashCode`.
- The hash code of an object is an integer value that obeys this property:
	> If two objects are equal (according to the equals method), they have the same hash code.

	- However, this does not mean every object with the same hash code has to be equal.

---
## Class (Static) Methods
```java
public static int population() {
	return Myclass.count;
}
```
- Since a class method is associated with the class and not the instance, we call it by prefixing it with the class name, like `Myclass.population()`.
- Although an instance method can reference a class variable (or call a class method), the opposite is not true. A class method **cannot** access an interface variable or call an instance method directly.
## Keyword `final`
```java
final int MAX_SIZE = 100;
```
- The `final` keyword is used to restrict modification. It can be applied to **variables**, **methods**, and **classes**.
- Note: if a `final` variable refers to an object, the reference itself cannot be changed, but the object it is referencing can still be **mutated**.
```java
final List<String> names = new ArrayList<>();
names.add("Alice"); // allowed — we're modifying the object
names = new ArrayList<>(); // not allowed — reassignment is forbidden
```
- `final` methods cannot be overridden by subclasses
- `final` classes cannot be subclassed.
