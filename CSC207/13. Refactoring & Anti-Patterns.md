## Refactoring
- Changing the code **without** changing its functionality
- Refactor to fix problems with the design
### Extract Method
❌ **Before**
```java
public void printReport(int[] scores) {
    System.out.println("Report:");
    int sum = 0;
    for (int score : scores) {
        System.out.println(score);
        sum += score;
    }
    double average = (double) sum / scores.length;
    System.out.println("Average: " + average);
}
```
- Create a helper method containing the code for one step of a longer method.
- Update the original method to call the helper.
✅ **After**
```java
public void printReport(int[] scores) {
    System.out.println("Report:");
    printScores(scores);
    printAverage(scores);
}

private void printScores(int[] scores) {
    for (int score : scores) {
        System.out.println(score);
    }
}

private void printAverage(int[] scores) {
    int sum = 0;
    for (int score : scores) sum += score;
    double average = (double) sum / scores.length;
    System.out.println("Average: " + average);
}
```
 - Each method now has a **single responsibility**.
 - **Improves readability**, easier to test and maintain.
### Change Method Declaration
❌ **Before**
```java
public double calc(double r, double h) {
    return Math.PI * r * r * h;
}
```
- Modify the parameter list to a method
- Update the method body as needed
- Update any calls to the method
✅ **After**
```java
public double calculateCylinderVolume(double radius, double height) {
    return Math.PI * radius * radius * height;
}
```
- **Improves clarit**y (by changing name of the method / parameters)
- **Adds flexibility** (by adding parameters)
- **Hide details** (by removing parameters)
### Encapsulate Fields
❌ **Before**
```java
public class Person {
    public String name;
}
```
- Change instance variable visibility to `private`.
- Add `getter` or `setter` as appropriate.
- Update client code to use `getter` and `setter`.
✅ **After**
```java
public class Person {
    private String name;

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
}
```
- **Controls access** to instance variables.
### Split Loop
❌ **Before**
```java
for (int i = 0; i < numbers.length; i++) {
    sum += numbers[i];
    if (numbers[i] % 2 == 0) evens++;
}
```
- Move independent operations from one loop into separate loops.
✅ **After**
```java
for (int i = 0; i < numbers.length; i++) {
    sum += numbers[i];
}
for (int i = 0; i < numbers.length; i++) {
    if (numbers[i] % 2 == 0) evens++;
}
```
- **Improves readability** and can make other refactoring techniques (like extract method) easier to perform.
### Slide Statements (Changing Order)
❌ **Before**
```java
int total = 0;
System.out.println("Starting calculation...");
for (int n : numbers) total += n;
```
- Reorder independent operations.
✅ **After**
```java
System.out.println("Starting calculation...");
int total = 0;
for (int n : numbers) total += n;
```
- **Improves readability** and can make other refactoring techniques (like extract method) easier to perform.
- **Group** together related operations.
### Replace Constructor with [Builder](12.%20Design%20Patterns.md#Builder)
❌ **Before**
```java
User u = new User("Alice", 25, "alice@example.com");
```
- Creates a `Builder` class with `setter`s to customize the object being built and a method to build the object.
- Update constructor calls in the client to use the Builder instead.
✅ **After**
```java
User u = new User.Builder()
		 .name("Alice")
		 .age(25)
		 .email("alice@example.com")
		 .build();
```
- **Improves readability** of code.
- Can replace the need for many overloaded constructors for customizable classes.
### Replace Constructor with [Factory](12.%20Design%20Patterns.md#Factory)
❌ **Before**
```java
public class User {
    private String name;
    private int age;

    public User(String name, int age) {  // public constructor
        this.name = name;
        this.age = age;
    }
}

// Client code:
User u = new User("Alice", 25);
```
- Define a new method that returns an instance of the class
- Hide the constructor from the client and have them use the factory method instead.
✅ **After**
```java
public class User {
    private String name;
    private int age;

    private User(String name, int age) {  // constructor now private
        this.name = name;
        this.age = age;
    }

    public static User createUser(String name, int age) {  // factory method
        return new User(name, age);
    }
}

// Client code:
User u = User.createUser("Alice", 25);  // replaces direct constructor call
```
- **Hides explicit calls** to the constructor.

> Memorize as **RRECESS**