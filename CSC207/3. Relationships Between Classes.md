## Inheritance
```java
class Child extends Parent {
	...
}
```
- The syntax above defines class `Child` to be a subclass of class `Parent`.
### Abstract Classes
```java
abstract class AbstractClass {
	abstract void something(); // abstract methods have no body
	
	void print() {
		System.out.println("Hi.");
	}
}
```
> **Abstracted Classes** are classes that are not meant to be initialized directly. 
- We use the `abstract` keyword to signify that a class is abstract
	- We also use the `abstract` keyword for methods to indicate any abstract methods.
	- Every `abstract` methods should be implemented in its subclasses, unless the subclass is `abstract`.
- When extending an abstract class, you can change the access modifier from `private` to `public`, but not `public` to `private`.
> A class can only **extend** a single class.
### Overriding Methods
```java
class Parent {
	void something() {
		... // some method body
	}
}
```

```java
class Child extends Parent {
	@Override
	void something() {
		... // our new method body
	}	
}
```
- `@Override` method is not *required*, but it helps to prevent errors.
## Interfaces
```java
interface Edible {
	// Methods that must be implemented by any class implementing Edible
	void eat(); // no abstract/pubilc keywords!
	// it can have arguments like: void eat(String food);
}
```

```java
interface Washable {
    // Default method that provides a basic implementation
    default void wash() {
        System.out.println("Washing the edible item...");
    }
}
```

```java
class Corn extends Plant implements Edible, Washable {
    void eat() {
        ...    // Our implementation here!
    }
    
    // Overriding the default wash method
    @Override
    public void wash() {
        System.out.println("Thoroughly washing the corn...");
    }
}
```
> An **interface** defines a contract for what a class can do, without specifying how it does it.
- It is used to defined *shared behavior* across potentially unrelated classes.
- In an interface:
	- All methods are implicitly `public` and `abstract`, unless marked otherwise.
	- Variables in an interface are implicitly `public`, `static`, and `final`.
		- You cannot have any other kinds of variable!
	- Classes that implement an interface must provide implementations for its **abstract methods**.
- From Java 8, interfaces can also includeâ€”
	1. `default` methods : methods with a body that is not required for classes to implement, but will work like one of its methods.
	2. `static` methods : useful for utility behaviour related to the interface.
>Unlike **abstract classes**,  a class can implement as many interfaces as it wants.
>Also, interfaces can also `extend` other interfaces.
## super()
```java
class Child extends Parent {
    int attribute1;
    int attribute2;

    public Child(int a, int b) {
        // There's no super() call here, but it's implicit!
        this.attribute1 = a;
        this.attribute2 = b;
    }
}
```
- When extending another class, Java *requires* a call to constructor of its superclass to be made in the constructor of the subclass.
- This **call** must be the very first thing done inside the constructor.
- If no `super` call is found, *implicit call* to `super()` will be made.
	- If superclass does not have constructor that takes no argument, this will cause an error during compilation.
## Polymorphism
```java
class Dog extends Canine implements Domesticatable { ... }
```
>**Polymorphism** is the ability of an object to take on many forms.
- An object can be treated as an instance of its own class, any superclass, or any interfaces it implements.
- A `Dog` object is:
	- `Dog`
	- `Canine`
	- `Domesticatable`
	- `Animal` (if `Canine` extends `Animal`)
	- `Object` (`Object` is at the top of hierarchy )
```java
Dog d = new Dog();
System.out.println(d instanceof Dog);              // true
System.out.println(d instanceof Canine);           // true
System.out.println(d instanceof Animal);           // true
System.out.println(d instanceof Object);           // true
System.out.println(d instanceof Domesticatable);   // true
```
> `instanceof` does not always mean both classes are parent/class relationship.

 - if an object can be safely cast to a type, it will be considered an instance of that class/interface.
 - A `instanceof` B means A can be safely cast to a type B.
```java
Animal[] animals = {new Cat(), new Dog(), new Axolotl()};

for (Animal a : animals){
    a.eat();    // 'a' in this line of code can have various types!
}
```
- This code exhibits **polymorphism** as `Cat`, `Dog`, `Axolotl` are all treated like an `Animal` inside the `for` loop.
## Casting
> All variables in Java have a **declared type**.

```java
Animal a = new Dog();
((Dog) a).bark();
```
- **Casting** is when we explicitly change the type of a reference to another, usually to access more specific functionality that isn't available in the more general type.
- Casting is safe **only** when the actual object is an instance of the target type.
	- If not, it will throw a `ClassCastException` at runtime.
- First line `Animal a = new Dog();` is an example of **upcasting**.
	- Upcasting is when we assign a subclass object to a superclass reference.
	- This is always safe, as every `Dog` is an `Animal`.
- Second line `((Dog) a).bark();` is an example of **downcasting**.
	- Downcasting is when we convert a superclass to a subclass.
	- It is only safe when `a instanceof Dog` is true.
>**IMPORTANT**: Casting changes the object's **reference type**, not the **object type**!
### Primitive Conversions
```java
int x = 1;
double y = 1.1;
double double_x = (double) x;
int int_y = (int) y;
```
- We can also cast some **primitives**, such as converting an `int` into `double`, and vice versa.
- Primitive casting can be:
	- Implicit (e.g. `int` to `double`) when there's no loss of data
	- Explicit (e.g. `double` to `int`) when there could be a loss of data (can't be implicit)
## Shadowing
```java
public class ShadowExample {
    private int x = 10;

    public void shadowingMethod(){
        int x = 20;
        System.out.println(x);
        System.out.println(this.x);
    }
}
```
 - The output will be `10` and `20`. 
	 - First `10` is a variable `x` which was initialized in `shadowingMethod()`.
	 - Second `20` is the instance variable `x`.
